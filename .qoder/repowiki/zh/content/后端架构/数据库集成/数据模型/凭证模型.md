# 凭证模型

<cite>
**本文档引用的文件**
- [models.py](file://vibe_surf/backend/database/models.py#L217-L235)
- [encryption.py](file://vibe_surf/backend/utils/encryption.py#L23-L40)
- [queries.py](file://vibe_surf/backend/database/queries.py#L1380-L1418)
- [composio.py](file://vibe_surf/backend/api/composio.py#L148-L194)
- [v006_add_credentials_table.sql](file://vibe_surf/backend/database/migrations/v006_add_credentials_table.sql)
</cite>

## 目录
1. [凭证模型字段定义](#凭证模型字段定义)
2. [凭证加密机制](#凭证加密机制)
3. [凭证模型关系映射](#凭证模型关系映射)
4. [Pydantic Schema与数据库模型对应关系](#pydantic-schema与数据库模型对应关系)
5. [凭证安全存储与检索示例](#凭证安全存储与检索示例)
6. [安全最佳实践与性能优化](#安全最佳实践与性能优化)

## 凭证模型字段定义

凭证模型（Credential）用于存储加密的API密钥和其他敏感数据。该模型包含以下字段：

- **id**：主标识符，使用UUID4生成的字符串，作为主键。
- **key_name**：凭证名称，字符串类型，长度限制为100个字符，不可为空且必须唯一。例如"COMPOSIO_API_KEY"。
- **encrypted_value**：加密值，文本类型，可为空。使用MAC地址进行加密的敏感数据。
- **description**：描述，文本类型，可为空，用于存储凭证的说明信息。
- **created_at**：创建时间，日期时间类型，不可为空，默认值为当前时间。
- **updated_at**：更新时间，日期时间类型，不可为空，默认值为当前时间，并在更新时自动更新。

该模型通过`idx_credentials_key_name`索引优化基于key_name的查找性能。

**Section sources**
- [models.py](file://vibe_surf/backend/database/models.py#L217-L235)
- [v006_add_credentials_table.sql](file://vibe_surf/backend/database/migrations/v006_add_credentials_table.sql)

## 凭证加密机制

凭证加密机制使用机器特定的密钥来加密和解密敏感数据，如API密钥。该机制的核心是基于机器MAC地址或本地用户ID派生加密密钥。

加密过程使用PBKDF2算法，具体参数如下：
- 算法：SHA256
- 密钥长度：32字节
- 盐值：固定的`b'vibesurf_warmshao_2025'`
- 迭代次数：100,000次

加密流程如下：
1. 首先尝试获取机器的MAC地址作为机器ID
2. 如果无法获取MAC地址，则使用本地用户ID作为替代
3. 使用`derive_key`函数基于机器ID和固定盐值派生加密密钥
4. 使用Fernet对称加密算法对API密钥进行加密
5. 将加密后的数据进行URL安全的Base64编码

解密过程与加密过程相反，但包含一个容错机制：如果使用MAC地址派生的密钥无法解密，系统会尝试使用本地用户ID派生的密钥进行解密，以应对机器环境变化的情况。

**Section sources**
- [encryption.py](file://vibe_surf/backend/utils/encryption.py#L23-L40)

## 凭证模型关系映射

凭证模型与其他核心组件的关系映射如下：

- **User**：凭证模型与用户模型之间存在隐式关系。虽然在当前实现中没有直接的外键关联，但凭证数据是用户级别的敏感信息，通过用户上下文进行访问控制。在早期的数据库迁移版本中曾包含user_id外键，表明了这种用户关联关系。

- **Agent**：代理组件通过凭证模型访问外部服务的API密钥。当代理需要调用外部工具时，会从凭证模型中检索相应的加密凭证，解密后用于API调用。

- **ComposioIntegration**：Composio集成与凭证模型有直接的交互关系。系统使用凭证模型存储Composio API密钥，通过`_get_composio_api_key_from_db`和`_store_composio_api_key_in_db`函数进行密钥的读取和存储。Composio工具的验证和连接状态检查都依赖于凭证模型中存储的加密API密钥。

这些关系确保了敏感凭证的安全管理和访问控制，同时支持了系统的集成能力。

**Section sources**
- [composio.py](file://vibe_surf/backend/api/composio.py#L148-L194)
- [queries.py](file://vibe_surf/backend/database/queries.py#L1380-L1418)

## Pydantic Schema与数据库模型对应关系

凭证模型相关的Pydantic Schema与数据库模型的对应关系如下：

- **CredentialCreate**：虽然没有显式的Pydantic创建模型，但在`CredentialQueries.store_credential`方法中，输入参数`key_name`、`value`和`description`对应于数据库模型的`key_name`、`encrypted_value`和`description`字段。创建过程中，系统会自动生成`id`并设置`created_at`和`updated_at`时间戳。

- **CredentialUpdate**：更新操作通过`CredentialQueries.update_credential`方法实现，接收`key_name`和新的`value`作为参数。更新时，系统会重新加密新值并更新`encrypted_value`字段，同时自动更新`updated_at`时间戳。

- **CredentialResponse**：虽然没有显式的响应模型，但`CredentialQueries.get_credential`方法返回解密后的凭证值，对应于数据库中的`encrypted_value`字段。响应中不直接暴露加密数据，而是提供解密后的可用凭证。

这种设计模式将凭证的加密/解密逻辑封装在数据库查询层，确保了敏感数据在传输过程中的安全性。

**Section sources**
- [queries.py](file://vibe_surf/backend/database/queries.py#L1380-L1418)

## 凭证安全存储与检索示例

以下是安全存储和检索加密凭证的实际代码示例：

```python
# 存储凭证
async def store_composio_api_key(api_key: str) -> bool:
    """安全存储Composio API密钥"""
    try:
        from .. import shared_state
        if not shared_state.db_manager:
            logger.warning("数据库管理器不可用")
            return False

        async for db in shared_state.db_manager.get_session():
            try:
                success = await CredentialQueries.store_credential(
                    db,
                    "COMPOSIO_API_KEY",
                    api_key,
                    "Composio API密钥用于工具集成"
                )
                if success:
                    await db.commit()
                    logger.info("✅ Composio API密钥存储成功")
                return success
            except Exception as e:
                logger.error(f"在数据库中存储Composio API密钥失败: {e}")
                return False
    except Exception as e:
        logger.error(f"存储Composio API密钥时数据库会话错误: {e}")
        return False
```

```python
# 检索凭证
async def get_composio_api_key_from_db() -> Optional[str]:
    """从数据库凭证表中获取Composio API密钥（加密）"""
    try:
        from .. import shared_state

        if not shared_state.db_manager:
            logger.warning("数据库管理器不可用")
            return None

        async for db in shared_state.db_manager.get_session():
            try:
                api_key = await CredentialQueries.get_credential(db, "COMPOSIO_API_KEY")
                return api_key
            except Exception as e:
                logger.error(f"从数据库检索Composio API密钥失败: {e}")
                return None
    except Exception as e:
        logger.error(f"检索Composio API密钥时数据库会话错误: {e}")
        return None
```

这些示例展示了如何通过安全的数据库查询接口进行凭证的存储和检索，确保了加密过程的透明性和安全性。

**Section sources**
- [composio.py](file://vibe_surf/backend/api/composio.py#L148-L194)

## 安全最佳实践与性能优化

凭证模型的安全最佳实践和性能优化建议如下：

### 安全最佳实践
1. **机器绑定加密**：使用MAC地址或本地用户ID作为密钥派生的基础，确保凭证只能在特定机器上解密，防止数据库泄露导致的凭证暴露。
2. **自动密钥回退**：实现双密钥机制，当主密钥（基于MAC地址）失效时，可回退到备用密钥（基于用户ID），提高用户体验的同时保持安全性。
3. **内存安全**：敏感数据在使用后应及时从内存中清除，避免长时间驻留。
4. **访问控制**：通过用户上下文限制凭证访问，确保用户只能访问自己的凭证数据。
5. **审计日志**：记录凭证的创建、更新和删除操作，便于安全审计和问题追踪。

### 性能优化
1. **索引优化**：为`key_name`字段创建唯一索引`idx_credentials_key_name`，确保快速查找和唯一性约束。
2. **连接池**：使用数据库连接池减少连接开销，提高并发性能。
3. **缓存策略**：对于频繁访问的凭证，可考虑在内存中缓存解密后的结果（需设置合理的过期时间），减少重复的加密/解密运算。
4. **批量操作**：当需要处理多个凭证时，使用批量操作减少数据库往返次数。
5. **异步处理**：所有数据库操作均采用异步模式，避免阻塞主线程，提高系统响应能力。

这些实践和优化措施共同确保了凭证系统的安全性、可靠性和高性能。

**Section sources**
- [encryption.py](file://vibe_surf/backend/utils/encryption.py#L23-L40)
- [models.py](file://vibe_surf/backend/database/models.py#L256-L257)